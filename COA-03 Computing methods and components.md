## 数据的表示方法和转换

### 数制

又称为“计数制”，是用一组固定的符号和统一的规则来表示数值的方法

三要素：**数码**（计数的符号）、**基数**（进位的单位）和**位权**（不同数码位的权值）

例如十进制：

- 数码：0,1,...,9
- 基数：10
- 位权：10^i^

表示方法

- 下标标注法：例如(1010)~2~，(1010)~10~
- 后缀标注法：375**Q**，A17**H**，101**B**

### 不同数制的进制转换

- ① R进制（二、八、十六）-> 十进制 
- ② 十进制 -> R进制（二、八、十六） 
- ③ 二进制 -> 八、十六进制 
- ④ 八、十六进制 -> 二进制 
- ⑤ 八进制 ⟺ 十六进制（通过二进制作媒介）

### 十进制数的编码与运算

**二进制编码的十进制数（Binary Code Decimal，BCD）**

- 方式：用四位二进制数来表示一位十进制数。
- 用途：广泛地运用于各种电子设备中，特别是在测试仪表及具有十进制输入输出的设备。
- 分类（根据二进制码的每一位是否有确定的权值）
  - 有权码：8421码、2421码、5211码、84-2-1码、4311码
  - 无权码：余3码、格雷码（用于计数器时，每次只有一位变化）

***余3码：对应的8421码加3而得**

## 带符号数原码、补码、反码、移码表示及相互转换

### 机器数

概念：计算机中表示的**带符号**的二进制数。

特点：符号数字化 & 数的大小受机器字长的限制。

表示方式（编码）

- 原码：最高位为符号位（0-正，1-负）；数值部分是真值绝对值的二进制数。
- 最高位为符号位（0-正，1-负）；数值部分，正数与原码相同，负数为原码按位取反。
- 补码：最高位为符号位（0-正，1-负）；数值部分，正数与原码相同，负数为反码加一。
- 移码：符号位取反的补码。

表示方式（数据）

- 定点数：小数点固定在某个位置上的数据。
- 浮点数：小数点位置可浮动的数据。

> 对于原码/反码来说，0的原码/反码有两个:exclamation:
>
> 减去一个数等价于加上这个数的补数（“变减为加”，简 化硬件）

移码：符号位取反的**补码**。

### 溢出

- 个异号数相加或两个同号数相减，其结果不会溢出。
- 两个同号数相加或两个异号数相减，才可能发生溢出。

#### 进位法

- OF=C~7~⊕C~6~（最高位进位与次高位进位异或）
- CF=C~7~⊕op（op=0为加，op=1为减）

#### 双符号位法

- 编码采用双符号位，正数和负数的符号位分别为00和11。
- 溢出：经过运算后，结果双符号位的两位不相同。

### 整数的类型转换

- 数据长度相同：无需操作，解释为新类型。
- 数据长度减少：截断操作，仅保留低位。
- 数据长度增加：位扩展操作，保持真值不变；位扩展分为零扩展和符号扩展。

## 带符号数运算

### 浮点数

定义：小数点位置可浮动的数据。

数学表示（科学计数法）

- 𝑁 = 𝑀×𝑅^E^
- 浮点数可用一对定点数表示：<尾数M，阶码E>

表数范围与精度：M 决定精度，E 决定范围。

> 例如：浮点数表示格式中，若尾数为9位、阶码为5位，尾数及阶均用补码表示，写出 (-54)~10~的浮点机器数。
>
> 解：(-54)~10~＝(-110110)~2~＝-0.11011000×2^+0110^，浮点机器数为
>
> M~s~=1, E=00110, M=00101000

#### IEEE 754浮点数

**表示方式**：分为单精度（32位）和双精度（64位）

- 单精度：数符S为1位，阶码E为8位，尾数M位23位
- 单精度：数符S为1位，阶码E为11位，尾数M位52位

**编码方式**

- 数制：M 和 E 均采用二进制，即基均为2。
- 码制：尾数 M 采用原码（但改变了点的位置），阶 E 采用移码（但改变了偏移值）。
- 最高位恒为1，在尾数表示中作为默认并省略 （目的：提高一位精度）
- 余127码（单精度）或余1023码（双精度） （目的：保留全0和全1作他用）

**余X码**：偏移值位X的移码

- 标准移码：真值＝E-2^8-1^＝E-128
- **余127码： 真值＝E-(2^8-1^-1)＝E-127**

**阶域**：若规定-126≤阶≤+127，那么1≤E≤254，表示规格化数

E＝0和255**另作他用**(如表示非规格化数、无穷大)

**尾数的码制**：支持非规格化尾数、规格化尾数两种方式

- 非规格化尾数：M真值＝±0.m-1…m-23，M表示＝Sm-1…m-23，尾数精度≤23位。
- 规格化尾数：M真值＝±1.m-2…m-24，M表示＝Sm-2…m-24，尾数精度＝24位。 以单精度为例

#### 规格化

规格化：目的使浮点数的表数精度最大化

规格化数：尾数的最高位数值为1，即 0.5≤|M|＜1

- 左规：尾数左移一位，阶码减一。
- 右规：尾数右移一位，阶码加一。

表示特征

- E=0，M=0：真值N=0，机器零（下溢区）
- E＝0，且M≠0：非规格化数
- 1≤E≤254：规格化数
- E＝255，且M≠0：N=NaN，非数值
- E＝255，且M＝0：±无穷大(上溢区)

## 定点数乘除运算

### 移位运算

运算功能：机器数左移或后移k位，相当于真值乘以或者除以2k。

- 逻辑移位（Logical shift）：逻辑左移，用 <<L 表示；逻辑右移，用 >>L 表示。
- 算术移位（Arithmetic shift）：算术左移，用 <<A 表示；算术右移，用 >>A 表示。

#### 逻辑移位

操作数类型：**无符号定点数**。

运算规则：机器数整体移位，移出的数位丢弃，出现的空位补0。

溢出判断逻辑：逻辑左移丢弃1时。（逻辑右移不会产生溢出，丢弃1时只损失精度）

#### 算术移位

操作数类型：**有符号定点数**（原码、补码等）。

运算规则：机器数符号位不变、数值位整体移位，移出的数位丢弃，出现的空位根据编码特征添补。

- 原码：左移补0，右移补0
- 补码：左移补0，右移补符号位
- 反码：左移补0（正数）/1（负数），右移补符号位

溢出条件：原码左移，最高数值位丢弃1时；补码左移，最高数值位丢弃与符号相反的码时。

溢出判断逻辑：类似于逻辑移位，从n-2位开始判断。

### 定点数的乘法运算

- 用循环（n-1次）的**加法**和**右移**实现；
-  加法时，根据乘数当前位，决定加（n-1位）被乘数或0（判断 -> 加法）；
- 右移时，加法进位、部分积高位、部分积低位一起右移（移位）。

硬件实现：加法器和**移位器**，阵列乘法器。

存储单元

- A寄存器：部分积，初值为0，最后保存乘积的高位部分；
- B寄存器：被乘数；
- C寄存器：乘数，运算结束后乘数不再保留，改为存放乘积的低位部分。

### 定点数的除法运算

实现思路

- 用循环的**减法**和**左移**实现；
- 减法时，判断是否够减，来确定上商，并计算余数；
- 左移时，余数，被除数低位同时左移。

## 浮点数的运算方法

### 浮点数的加减运算

基本过程：设浮点数A=M~A~×2^EA^ 、B=M~B~×2^EB^，且E~A~≤E~B~

- ① 对阶操作：**小阶向大阶看齐**，使阶码相等（结果的阶＝EB，A＝(MA×2^EA-EB^)×2^EB^ ）；
- ② 尾数运算：阶码对其后直接对尾数运算（结果的尾数＝M~A~×2^EA-EB^±MB）；
- ③ 结果规格化：对运算结果进行规格化处理；
- ④ 舍入操作：丢失位进行0舍1入或恒置1处理；
- ⑤ 判断溢出：判断阶码是否溢出，下溢则将运算结果置0，上溢则中断。

#### 对阶操作

- 求公共阶：E’F＝max(EA,EB)，ΔE＝|EA-EB|；
- 小阶尾数算术右移：移出的数值→附加位（减少精度损失）。

#### 尾数运算

- M‘F＝M’A±M‘B，尾数及附加位一起运算；
- 由于有后续规格化步骤，该步骤结果溢出不算出错。

#### 结果规格化

- |M’F|≥1.0时 -> 1次右规
- 0.5≤|M’F|＜1.0时 -> 无操作(已为规格化数)
- |M‘F|＜0.5时 -> x次左规、直到|M‘’F|≥0.5

#### 舍入操作

- 截断法：尾数不变；
- 舍入法：附加位最高位（真值）为1时入，否则舍；
- 恒置1法：将尾数末位置1。

#### 判断溢出

- 目的：判断阶码是否上溢或下溢，并处理；
- 处理（以IEEE 754标准为例）
  - EF上溢时，结果置为±∞([EF]移＝255,[MF]原＝0)
  - EF下溢时，结果置为机器零([EF]移＝0,[MF]原＝0)

## 数据校验

原理：接收的检验码∈{合法码字，非法码字}

- 检错：检查接收的校验码是否为非法码字；
- 纠错：根据非法码字定位错误、纠正错误。

校验过程：冗余校验思想

- 用待发数据M形成校验信息P，M与P一起传送；
- 用接收数据M’形成校验信息P‘’，用P‘及P‘’校验数据、返回CHK状态。

### 码距

- 码距为1：既不能检错也不能纠错。

- 码距越大：检错、纠错能力越强。

策略：加入校验位，扩大码距，找出错误。

### 奇偶校验码

略

### 循环冗余校验码（CRC）

编码原理：使CRC码能够被整除

- CRC码的构成：k位数据位M(x)和r位检验位R(x)；
- 多项式表示：M(x) · x^k^ + R(x)；
- 检验位的编码：M(x)左移r位后，模2除以G(x)的余数。
- 通过余数查表获得出错的位置，若余数为0则无出错

