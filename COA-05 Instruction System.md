## 指令系统概述

意义：反映硬件实现的所有功能。

概念

- 机器指令：硬件可直接识别和执行的命令。
- 指令系统：所有机器指令的集合，即指令集（Instruction Set）。

指令的表示：用一定格式的二进制编码表示，内容包括**操作码**和**地址码**。

**本质（软硬件的重要交界面）**

机器指令：指令功能和指令格式之间的约定。

*指令系统：**设计内容**将决定计算机的**结构**，**实现过程**将完成计算机的**组织**。

### 指令系统的要求

- 完备性

  指令系统直接提供的指令**足够使用**，相关功能不需用软件实现。（乘法指令 vs 加法指令）

- 有效性

  指令级程序占据的**存储空间小、执行速度快、能够高效运行**。（访存效率 + 执行效率）

- 规整性

  **对称性、匀齐性**、执行格式与数据格式的**一致性**。（变长指令 vs 定长指令）

- 兼容性

  - 向上兼容：低档机器的软件能在高档机器上运行。
  - 向前兼容：早期机器的软件能在最新机器上运行。

## 指令格式

内容：**操作码**、操作数的地址、操作结果的存储地址、下一条指令的地址（**地址码**）。

### 指令格式分类（根据地址码部分的地址个数）

- 零地址指令：指令中只有操作码，没有操作数或操作数地址。

  - 无需操作数：如空操作指令，停机指令。
  - 操作数地址默认：如操作数或其地址安排在默认的寄存器中。

- 一地址指令：指令中**只给出一个地址码**。

  - 只需一个地址码：如跳转、或同时作为读/写地址。
  - 其他地址码默认：第二个操作数安排在默认的寄存器中。

- 二地址指令：指令中有两个地址码。

  一般两个均作为源操作数地址，且其中一个也同时作为存放结果的目的地址。

- 三地址指令：指令中有三个地址码。

  两个作为源操作数地址，另一个作存放结果的目的地址。

- 多地址指令：指令中有多个地址码。

  要求高性能的场景下，成批处理数据时，同时访问多个操作数地址。

#### 地址码

表示信息：显式和隐式。

- 寄存器地址：寄存器编号等。
- 存储单元地址：相对地址、绝对地址等。
- 下一条指令地址：跳转指令显式、其他指令隐式（默认PC=PC +“1”）。
- 立即数：如 MOV $0, 1001B（R0 ← 1001B）

编码方式：结合操作码后，能**唯一地**标识访问对象。

- 内容：寄存器/存储单元的地址或立即数的数值。
- 压缩：地址位数一般较长，希望通过较短的地址码来间接表示具体的地址。（寻址方式）

> 例如：某指令系统中，有零指令、单指令、双指令3种指令格式，指令字长都为16位，每个地址码为6位。 
>
> (1) 若操作码采用定长编码，且已定义3条零地址指令、4条单地址指令，则双地址指令最多有多少条？
>
> 9条。
>
> (2) 若操作码采用变长编码，且已定义48条零地址指令、14条双地址指令，则单地址指令最多有多少条？
>
> 127条。

### 指令格式的设计

组成：指令格式 + 指令编码。

性能：影响译码复杂度、存储空间

- 规整性：操作码长度是否相等、地址码格式是否一致、目的操作数位置是否固定等。
- 平均码长：程序中所有**指令字长**（一条指令所包含二进制信息的位数）的平均值。

#### 指令操作码的扩展技术

思路：对不需要某个地址码的指令，将**地址码字段扩充为操作码**。

- 优点：充分利用指令字的各字段，在不增加指令长度的情况下表示更多指令；
- 缺点：增加了译码的复杂度。

方法：基于**霍夫曼编码**的操作码，即根据程序中指令出现频率高低而赋以不同长度的操作码。

**霍夫曼编码的操作**：依次合并权重最小的两个结点，是其成为一个新的结点，再重复该操作。最后的编码方式，从主结点依次向下遍历，往左指令+1，往右指令+0。

### 指令字长

分类：相对于机器字长进行分类为单字长指令、双字长指令、半字长指令。

指令集结构：根据指令字长的特点，分为定长指令字结构和变长指令字结构。

#### *四种重要概念

- 存储字长

  - 存储器中**一个存储单元**（存储地址）所存储的二进制信息的位数

  - 特征：可寻址最小单元,例如8位。

- 指令字长

  - 一条指令中所包含二进制信息的位数
  - m×存储字长，例如32位

- 数据字长

  - 计算机各类型数据存储所占的二进制位数
  - n×存储字长，例如64位double

- 机器字长

  - CPU一次能处理数据的最大位数
  - k×存储字长，常数，例如32/64位机

### 数据字长

#### 指令/数据的存放方式

指令/数据特性：存在变长指令、同一类数据也可有多种长度（类型，如short、int）。

存放位置

- 寄存器：寄存器长度 = **机器字长** = **最长数据**的长度。
- 存储器：一般以字节（8位）为最小单位存储，访问时可按字节、半字、字或双字进行。

#### 数据存放在寄存器

长数据（长度=寄存器长度）：占用寄存器的全部位数。

短数据（长度<寄存器长度）

- 寄存器低端：便于寻址，但浪费空间；
- 部分寄存器：充分利用寄存器空间，但指令编码中需要考虑寻址方式。

#### 数据存放在存储器

最短数据（长度=存储单元长度）：占用存储单元的全部位数。

长数据（长度=n×存储单元长度）：数据内容存放在连续的存储单元中。

字节顺序（Endian）问题：大端方式和小端方式，无所谓好坏之分。

- 大端：从存储地址大的一端开始存储低位数据
- 小端：从存储地址小的一段开始存储低位数据

字节对齐（Alignment）问题

- 不对齐虽然节省存储空间，但可能会引起“读一个数据需两次访存操作”的后果。
- 默认采用边界对齐：数据地址为数据长度的倍数，即长度为2n字节的数据，地址最低n位为须为0。

> 例：设存储器按字（32位）访问，两种方式下，分别读取6个数据A～F共需多少次访存操作？
>
> 见ppt

## 寻址方式

寻址方式：根据指令中的地址码确定**数据地址**和**下条指令地址**的方法。

操作部件：主要为寄存器、存储器。

内容

- 指令寻址：确定下一条要执行的指令地址；
- 数据寻址：确定指令使用的操作数的地址。

### 指令寻址

指令类型：顺序型指令、转移型指令。

- 顺序寻址：下一条指令地址PC=PC +“1”，形成方法与当前指令内容无关，隐式表示。
- 跳转寻址：下一条指令地址PC=𝒇(地址码) ，形成方法与当前指令中的地址码有关，常显式表示。
- 识别：在指令译码阶段，通过**操作码**区分。

### 数据寻址

含义：根据地址码形成数据的有效地址，寻址方式通过**地址码**区分。

- 形式地址A（Address）：指令的地址码所表示的地址，通常**不代表操作数的真实地址**。
- 有效地址EA（Effective Address）：操作数的真实地址，由**寻址方式和形式地址**共同确定。

**寻址方式：立即数寻址、寄存器寻址、直接寻址、相对寻址、间接寻址、基址寻址、变址寻址等。**

目标：缩短地址码长度，方便编译程序形成代码。

### 数据寻址（数据在指令中）

立即数寻址：地址码本身即为操作数。

- 一般采用**补码**形式存放。
- 取出指令就可以获得操作数，**不必访问内存**（速度快）。
- 地址码的位数限制了立即数的**取值范围**。
- OPD＝Immediate

### 数据寻址（数据在寄存器）

寄存器寻址：地址码为寄存器（REG）编号。

- 操作数不在内存中，而放在CPU的通用寄存器中（减少了执行执行时间）。
- 形式地址A表示的是寄存器的编号。
- 寄存器编号一般较短，故可以压缩指令字，节省存储空间。
- 地址码的位数将制约寄存器的个数。
- OPD＝(Ri)

### 数据寻址（数据在存储器）

- 直接寻址：指令中的形式地址A即为有效地址EA。
  - 优点：寻找操作数较简单，无需专门计算有效地址，访存一次取得操作数。

- 缺点：A的位数限制了操作数的寻址范围。
- EA＝A

（寄存器）间接寻址：操作数存放在存储器中，形式地址A为存放操作数地址的寄存器编号。

## 指令类型